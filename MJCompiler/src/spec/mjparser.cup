package rs.ac.bg.etf.pp1;
import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

scan with {:
    Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, CONST, ASSIGN, SEMICOLON, COMMA,
    CLASS, EXTENDS, LEFT_CURLY_BRACE, RIGHT_CURLY_BRACE,
    LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET,
    LEFT_PARENTHESIS, RIGHT_PARENTHESIS, VOID, BREAK,
    CONTINUE, EQUALS, NOT_EQUALS, GREATER_THAN_OR_EQUAL_TO,
    GREATER_THAN, LESSER_THAN_OR_EQUAL_TO, LESSER_THAN,
    ADD, SUB, MUL, DIV, MOD, LOGICAL_AND, LOGICAL_OR, RETURN, NEW,
    DOT, QUESTION_MARK, COLON, READ, PRINT, DO, WHILE, IF, ELSE,
    SWITCH, CASE, POSTINC, POSTDEC, ENUM;

terminal String IDENT;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;
terminal Integer NUMCONST;

/* Program related nonterminals */
nonterminal Program;

/* Variable, Const and Class definition related nonterminals */
nonterminal DeclList, ConstDeclListWithErrorRecovery, VarDeclList, VarDecl,
        OptionalVarDeclList, ClassDecl, OptionalArrayBrackets, ConstDecl,
        ConstValue, OptionalExtendedClassLBrace, Type, ConstDeclList,
        GlobalVarDeclListWithErrorRecovery,
        ClassOptionalVarDeclList, ClassVarDecls, ConstDeclWithCOMMA,
        GlobalVarDecl, GlobalVarDeclWithCOMMA;

/* Method definition related nonterminals */
nonterminal MethodDeclListWithBraces, MethodDeclList, MethodDecl,
        VoidOrType, OptionalFormPars, FormsPars, FormParamWithCOMMA,
        FormArgsStart, FormArgsEnd;

/* Expression related nonterminals */
nonterminal StatementList, Statement, OptionalMinus,
        OptionalExpr, Assignop, Addop, Mulop, Relop,
        OptionalExprInBrackets, OptionalActPars,
        OptionalActParsWithBrackets, ActPars, Condition, CondTerm,
        CondFact;

/* Statement related nonterminals */
nonterminal FullPrintStatement, DesignatorStatementOptions,
        OptionalElseStatement, CaseList, ConditionExpr,
        AssignStatementRecover, IfCondExpr, AssignDesignator,
        ReadDesignator, FunctionCallStatement;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodReturnTypeAndName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Expr, Term, TermExpr, Factor, SubTerm, AddopTerm;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;

precedence left ELSE;

Program ::= (Program) PROGRAM ProgName:p DeclList
    LEFT_CURLY_BRACE MethodDeclList RIGHT_CURLY_BRACE;

ProgName ::= (ProgName) IDENT:progName;

DeclList ::= (GlobalConstDeclList) DeclList ConstDeclListWithErrorRecovery
    | (GlobalVarDeclList) DeclList GlobalVarDeclListWithErrorRecovery
    | (ClassDeclList) DeclList ClassDecl
    | (NoDeclList);

ConstDeclListWithErrorRecovery ::= (FullConstDeclListWithErrorRecovery) CONST Type ConstDeclList
    | (ErrorConstDeclWithErrorRecovery) CONST error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak unutar definicije const globalne promenljive do SEMICOLON-a [1], linija " + lleft, null); :}
    ;

ConstDeclList ::= (FullConstDeclWithSEMICOLON) ConstDecl SEMICOLON
    | (ErrorConstDeclWithSEMICOLON) error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak unutar definicije const globalne promenljive do SEMICOLON-a [2], linija " + lleft, null); :}
    | (ConstDeclListCOMMA) ConstDeclWithCOMMA ConstDeclList
    ;

ConstDeclWithCOMMA ::= (FullConstDeclWithCOMMA) ConstDecl COMMA
    | (ErrorConstDeclWithCOMMA) error COMMA:l
    {: parser.report_error("Izvrsen oporavak unutar definicije const globalne promenljive do COMMA, linija " + lleft, null); :}
    ;

ConstDecl ::= (ConstDecl) IDENT:constName ASSIGN ConstValue;

GlobalVarDeclListWithErrorRecovery ::= (FullGlobalVarDeclList) Type GlobalVarDecl
    | (ErrorGlobalVarDeclList) error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak unutar deklaracije globalne promenljive do SEMICOLON-a [1], linija " + lleft, null); :}
    ;

GlobalVarDecl ::= (FullGlobalVarDecl) VarDecl SEMICOLON
    | (ErrorGlobalVarDecl) error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak unutar deklaracije globalne promenljive do SEMICOLON-a [2], linija " + lleft, null); :}
    | (FullGlobalVarDeclWithCOMMA) GlobalVarDeclWithCOMMA GlobalVarDecl
    ;

GlobalVarDeclWithCOMMA ::= (NextGlobalVarDeclWithCOMMA) VarDecl COMMA
    | (ErrorGlobalVarDeclWithCOMMA) error COMMA:l
    {: parser.report_error("Izvrsen oporavak unutar deklaracije globalne promenljive do COMMA-e, linija " + lleft, null); :}
    ;

ClassDecl ::= (ClassDecl) CLASS IDENT OptionalExtendedClassLBrace ClassOptionalVarDeclList
    MethodDeclListWithBraces RIGHT_CURLY_BRACE;

ClassOptionalVarDeclList ::= (FullClassVarDecl) ClassOptionalVarDeclList ClassVarDecls
    | (NoClassVarDecls);

ClassVarDecls ::= (RegularClassVarDecls) VarDeclList SEMICOLON
    | (ErrorClassVarDecls) error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak unutar definicije poljan klase, liniji " + lleft, null); :}
    ;

MethodDeclListWithBraces ::= (FullMethodDeclListWithBraces) LEFT_CURLY_BRACE MethodDeclList RIGHT_CURLY_BRACE
    | (NoMethodDeclListWithBraces);

MethodDeclList ::= (MethodDecls) MethodDeclList MethodDecl
    | (NoMethodDeclList);

MethodDecl ::= (MethodDecl) MethodReturnTypeAndName FormArgsStart OptionalFormPars
    OptionalVarDeclList LEFT_CURLY_BRACE StatementList RIGHT_CURLY_BRACE;

MethodReturnTypeAndName ::= (MethodReturnTypeAndName) VoidOrType IDENT:methodName;

FormArgsStart ::= (FormArgsStart) LEFT_PARENTHESIS;
FormArgsEnd ::= (FormArgsEnd) RIGHT_PARENTHESIS;

VoidOrType ::= (VoidReturnType) VOID
    | (ReturnType) Type;

OptionalFormPars ::= (FullFormPars) FormsPars
    | (NoFormParams) FormArgsEnd;

FormsPars ::= (FormParamWithPAREN) Type VarDecl FormArgsEnd
    | (ErrorFormParamWithPAREN) error RIGHT_PARENTHESIS:l
    {: parser.report_error("Izvrsen oporavak unutar definicije formalnih parametara metode do ')', linija " + lleft, null); :}
    | (InnerFormParamWithCOMMA) FormParamWithCOMMA FormsPars;

FormParamWithCOMMA ::= (FullFormParamWithCOMMA) Type VarDecl COMMA
    | (ErrorFormParamWithCOMMA) error COMMA:l
    {: parser.report_error("Izvrsen oporavak unutar definicije formalnih parametara metode do ',', linija " + lleft, null); :}
    ;

StatementList ::= (MethodStatement) StatementList Statement
    | (NoStatement);

Statement ::= (DesignatorStatement) DesignatorStatementOptions
    | (IfElseStatement) IF IfCondExpr Statement OptionalElseStatement
    | (DoWhileStatement) DO Statement WHILE LEFT_PARENTHESIS ConditionExpr RIGHT_PARENTHESIS SEMICOLON
    | (SwitchStatement) SWITCH LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS LEFT_CURLY_BRACE CaseList RIGHT_CURLY_BRACE
    | (BreakStatement) BREAK SEMICOLON
    | (ContinueStatement) CONTINUE SEMICOLON
    | (ReturnStatement) RETURN OptionalExpr SEMICOLON
    | (ReadStatement) READ LEFT_PARENTHESIS ReadDesignator RIGHT_PARENTHESIS SEMICOLON
    | (PrintStatement) FullPrintStatement SEMICOLON
    | (NestedStatement) LEFT_CURLY_BRACE StatementList RIGHT_CURLY_BRACE
    ;

IfCondExpr ::= (RegularIfCondExpr) LEFT_PARENTHESIS ConditionExpr RIGHT_PARENTHESIS
    | (ErrorIfCondExpr) error RIGHT_PARENTHESIS:l
    {: parser.report_error("Izvrsen oporavak od nekorektnog logickog iskaza unutar if-a, liniji " + lleft, null); :}
    ;

DesignatorStatementOptions ::= (AssignStatementWithErrRecovery) AssignStatementRecover
    | (FunctionCall) FunctionCallStatement SEMICOLON
    | (PostIncrement) Designator POSTINC SEMICOLON
    | (PostDecrement) Designator POSTDEC SEMICOLON;

AssignStatementRecover ::= (AssignExpr) AssignDesignator Assignop Expr SEMICOLON
    | (AssignExprError) error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak od nekorektnog iskaza dodele, liniji " + lleft, null); :}
    ;

FunctionCallStatement ::= (FunctionCallStatement) Designator LEFT_PARENTHESIS OptionalActPars RIGHT_PARENTHESIS;

ReadDesignator ::= (ReadDesignator) Designator;

AssignDesignator ::= (AssignDesignator) Designator;

OptionalElseStatement ::= (ElseStatement) ELSE Statement
    | (NoElseStatement);

CaseList ::= (Case) CaseList CASE NUMCONST COLON StatementList
    | (NoCase);

FullPrintStatement ::= (SimplePrintStatement) PRINT LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
    | (ParameterizedPrintStatement) PRINT LEFT_PARENTHESIS Expr COMMA NUMCONST RIGHT_PARENTHESIS;

OptionalExpr ::= (FullExpr) Expr
    | (NoExpr);

ConditionExpr ::= (TernaryConditionExpr) Condition QUESTION_MARK ConditionExpr COLON ConditionExpr
    | (RegularConditionExpr) Condition;

/*---------------IMPORTANT---------------*/
Expr ::= (TernaryExpr) Condition QUESTION_MARK Expr COLON Expr
    | (RegularExpr) TermExpr;

Condition ::= (NextCondition) Condition LOGICAL_OR CondTerm
    | (SingleCondition) CondTerm;

CondTerm ::= (NextCondTerm) CondTerm LOGICAL_AND CondFact
    | (SingleCondTerm) CondFact;

/*---------------IMPORTANT---------------*/
CondFact ::= (FullCondFact) TermExpr Relop TermExpr
    | (SingleCondFact) TermExpr;

TermExpr ::= (NextTermExpr) TermExpr AddopTerm
    | (SingleTermExprWithMinus) SubTerm
    | (SingleTermExpr) Term
    ;

SubTerm ::= (SubTerm) SUB Term;

AddopTerm ::= (AddopTerm) Addop Term;

Term ::= (NextTerm) Term Mulop Factor
    | (SingleTerm) Factor;

Factor ::= (FuncCall) FunctionCallStatement
    | (DesignatorFactor) Designator
    | (ConstFactor) ConstValue
    | (NewOperatorFactor) NEW Type OptionalExprInBrackets
    | (ExprFactor) LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
    ;

OptionalExprInBrackets ::= (FullExprInBrackets) LEFT_SQUARE_BRACKET Expr RIGHT_SQUARE_BRACKET
    | (NoExprInBrackets);

// OptionalActParsWithBrackets ::= (FullActParsWihBrackets) LEFT_PARENTHESIS OptionalActPars RIGHT_PARENTHESIS
//     | (NoActParsWithBrackets);

OptionalActPars ::= (FullActPars) ActPars
    | (NoActPars);

ActPars ::= (NextActPar) ActPars COMMA Expr
    | (SingleActPar) Expr;

Designator ::= (InnerDotIdentDesignator) Designator DOT IDENT:classField
    | (InnerExprInBracketsDesignator) Designator LEFT_SQUARE_BRACKET Expr RIGHT_SQUARE_BRACKET
    | (SingleDesignator) IDENT:name;

// OptionalMinus ::= (Minus) SUB | (NoMinus);

OptionalVarDeclList ::= (FullVarDeclList) OptionalVarDeclList Type VarDeclList SEMICOLON
    | (NoVarDeclList);

VarDeclList ::= (NextVarDecl) VarDeclList COMMA VarDecl
    | (SingleDecl) VarDecl;

VarDecl ::= (VarDecl) IDENT:varName OptionalArrayBrackets;

ConstValue ::= (NumberConst) NUMCONST | (CharConst) CHARCONST | (BooleanConst) BOOLCONST;

OptionalExtendedClassLBrace ::= (ExtendedClass) EXTENDS Type LEFT_CURLY_BRACE
    | (ErrorExtendedClass) error LEFT_CURLY_BRACE:l
    {: parser.report_error("Izvrsen oporavak nekorektnog prosirenja klase, liniji " + lleft, null); :}
    | (NoExtendedClass) LEFT_CURLY_BRACE;

OptionalArrayBrackets ::= (ArrayBrackets) LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET
    | (NoArrayBrackets);

Type ::= (Type) IDENT:typeName;

Assignop ::= (Assignop) ASSIGN;

Relop ::= (EqualsRelop) EQUALS
    | (NotEqualsRelop) NOT_EQUALS
    | (GreaterEqualsRelop) GREATER_THAN_OR_EQUAL_TO
    | (GreaterRelop) GREATER_THAN
    | (LesserEqualsRelop) LESSER_THAN_OR_EQUAL_TO
    | (LesserRelop) LESSER_THAN;

Addop ::= (AddAddop) ADD
    | (SubAddop) SUB;

Mulop ::= (MulMulop) MUL
    | (DivMulop) DIV
    | (ModMulop) MOD;
