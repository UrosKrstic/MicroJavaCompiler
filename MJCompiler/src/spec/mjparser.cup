package rs.ac.bg.etf.pp1;
import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    Logger log = Logger.getLogger(getClass());
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

scan with {:
    Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, CONST, ASSIGN, SEMICOLON, COMMA,
    CLASS, EXTENDS, LEFT_CURLY_BRACE, RIGHT_CURLY_BRACE,
    LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET,
    LEFT_PARENTHESIS, RIGHT_PARENTHESIS, VOID, BREAK,
    CONTINUE, EQUALS, NOT_EQUALS, GREATER_THAN_OR_EQUAL_TO, 
    GREATER_THAN, LESSER_THAN_OR_EQUAL_TO, LESSER_THAN,
    ADD, SUB, MUL, DIV, MOD, LOGICAL_AND, LOGICAL_OR, RETURN, NEW,
    DOT, QUESTION_MARK, COLON, READ, PRINT, DO, WHILE, IF, ELSE,
    SWITCH, CASE, POSTINC, POSTDEC, ENUM;

terminal String IDENT;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;
terminal Integer NUMCONST;

nonterminal Program, DeclList, ConstDecls, VarDecls,
    ConstDecl, VarDecl, OptionalVarDeclList, ClassDecl, OptionalArrayBrackets,
    ConstValue, OptionalExtendedClassLBrace, Type, MethodDeclListWithBraces, MethodDeclList,
    MethodDecl, VoidOrType, OptionalFormPars, FormsPars, StatementList, Statement,
    Term, OptionalMinus, OptionalExpr, Expr, Assignop, Addop, Mulop, Relop, Factor,
    Designator, OptionalExprInBrackets,
    OptionalActPars, OptionalActParsWithBrackets, ActPars,
    Condition, CondTerm, CondFact, TermExpr, FullPrintStatement,
    DesignatorStatementOptions, OptionalElseStatement, CaseList, ConditionExpr,
    GlobalVarDecls, GlobalVarDecl, AssignStatementRecover, IfCondExpr,
    ClassOptionalVarDeclList, ClassVarDecls;

precedence  left  ELSE;

Program ::= (Program) PROGRAM IDENT DeclList
    LEFT_CURLY_BRACE MethodDeclList RIGHT_CURLY_BRACE;

DeclList ::= (ConstDeclList) DeclList ConstDecls
    | (VarDeclLists) DeclList GlobalVarDecls
    | (ClassDeclList) DeclList ClassDecl
    | (NoDeclList);

ConstDecls ::= (FullConstDecl) CONST Type ConstDecl SEMICOLON
    | (ErrorConstDeclsSEMICOLON) CONST error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak unutar definicije const globalne promenljive, linija " + lleft, null); :}
    ;

ConstDecl ::= (NextConstDecl) ConstDecl COMMA IDENT ASSIGN ConstValue
    | (ErrorConstDecl) error:l
    {: parser.report_error("Izvrsen oporavak unutar definicije const globalne promenljive, linija " + lleft, null); :}
    | (SingleConstDecl) IDENT ASSIGN ConstValue;

GlobalVarDecls ::= (FullGlobalVarDecls) Type GlobalVarDecl SEMICOLON
    | (ErrorGlobalVarDecls) error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak unutar definicije globalne promenljive, linija " + lleft, null); :}
    ;

GlobalVarDecl ::= (NextGlobalVarDecl) GlobalVarDecl COMMA IDENT OptionalArrayBrackets
    | (ErrorGlobalDecl) error:l
    {: parser.report_error("Izvrsen oporavak unutar definicije globalne promenljive, linija " + lleft, null); :}
    | (SingleVarDecl) IDENT OptionalArrayBrackets;

ClassDecl ::= (ClassDecl) CLASS IDENT OptionalExtendedClassLBrace ClassOptionalVarDeclList
    MethodDeclListWithBraces RIGHT_CURLY_BRACE;

ClassOptionalVarDeclList ::= (FullClassVarDecl) ClassOptionalVarDeclList ClassVarDecls
    | (NoClassVarDecls);

ClassVarDecls ::= (RegularClassVarDecls) VarDecl SEMICOLON
    | (ErrorClassVarDecls) error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak unutar definicije polja klase, liniji " + lleft, null); :}
    /* | (ErrorClassVarDeclsLBrace) error LEFT_CURLY_BRACE:l
    {: parser.report_error("Izvrsen oporavak unutar definicije polja klase, liniji " + lleft, null); :} */
    ;

MethodDeclListWithBraces ::= (FullMethodDeclListWithBraces) LEFT_CURLY_BRACE MethodDeclList RIGHT_CURLY_BRACE
    | (NoMethodDeclListWithBraces);

MethodDeclList ::= (MethodDecls) MethodDeclList MethodDecl
    | (NoMethodDeclList);

MethodDecl ::= (MethodDecl) VoidOrType IDENT LEFT_PARENTHESIS OptionalFormPars
    OptionalVarDeclList LEFT_CURLY_BRACE StatementList RIGHT_CURLY_BRACE;

VoidOrType ::= (VoidReturnType) VOID
    | (ReturnType) Type;

OptionalFormPars ::= (FullFormPars) FormsPars RIGHT_PARENTHESIS
    | (NoFormParams) RIGHT_PARENTHESIS;

FormsPars ::= (InnerFormParam) FormsPars COMMA Type IDENT OptionalArrayBrackets
    | (ErrorFormsPars) error:l
    {: parser.report_error("Izvrsen oporavak unutar definicije formalnih parametara metode, liniji " + lleft, null); :}
    | (SingleFormParam) Type IDENT OptionalArrayBrackets;

StatementList ::= (MethodStatement) StatementList Statement
    | (NoStatement);

Statement ::= (DesignatorStatement) DesignatorStatementOptions
    | (IfElseStatement) IF IfCondExpr Statement OptionalElseStatement
    | (DoWhileStatement) DO Statement WHILE LEFT_PARENTHESIS ConditionExpr RIGHT_PARENTHESIS SEMICOLON
    | (SwitchStatement) SWITCH LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS LEFT_CURLY_BRACE CaseList RIGHT_CURLY_BRACE
    | (BreakStatement) BREAK SEMICOLON
    | (ContinueStatement) CONTINUE SEMICOLON
    | (ReturnStatement) RETURN OptionalExpr SEMICOLON
    | (ReadStatement) READ LEFT_PARENTHESIS Designator RIGHT_PARENTHESIS SEMICOLON
    | (PrintStatement) FullPrintStatement SEMICOLON
    | (NestedStatement) LEFT_CURLY_BRACE StatementList RIGHT_CURLY_BRACE
    ;

IfCondExpr ::= (RegularIfCondExpr) LEFT_PARENTHESIS ConditionExpr RIGHT_PARENTHESIS
    | (ErrorIfCondExpr) error RIGHT_PARENTHESIS:l
    {: parser.report_error("Izvrsen oporavak od nekorektnog logickog iskaza unutar if-a, liniji " + lleft, null); :}
    ;

DesignatorStatementOptions ::= (AssignStatementWithErrRecovery) AssignStatementRecover
    | (FunctionCall) Designator LEFT_PARENTHESIS OptionalActPars RIGHT_PARENTHESIS SEMICOLON
    | (PostIncrement) Designator POSTINC SEMICOLON
    | (PostDecrement) Designator POSTDEC SEMICOLON;

AssignStatementRecover ::= (AssignExpr) Designator Assignop Expr SEMICOLON
    | (AssignExprError) error SEMICOLON:l
    {: parser.report_error("Izvrsen oporavak od nekorektnog iskaza dodele, liniji " + lleft, null); :}
    ;

OptionalElseStatement ::= (ElseStatement) ELSE Statement
    | (NoElseStatement);

CaseList ::= (Case) CaseList CASE NUMCONST COLON StatementList
    | (NoCase);

FullPrintStatement ::= (SimplePrintStatement) PRINT LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
    | (ParameterizedPrintStatement) PRINT LEFT_PARENTHESIS Expr COMMA NUMCONST RIGHT_PARENTHESIS;

OptionalExpr ::= (FullExpr) Expr
    | (NoExpr);

ConditionExpr ::= (TernaryConditionExpr) Condition QUESTION_MARK ConditionExpr COLON ConditionExpr
    | (RegularConditionExpr) Condition;

/*---------------IMPORTANT---------------*/
Expr ::= (TernaryExpr) Condition QUESTION_MARK Expr COLON Expr
    | (RegularExpr) TermExpr;

Condition ::= (NextCondition) Condition LOGICAL_OR CondTerm
    | (SingleCondition) CondTerm;

CondTerm ::= (NextCondTerm) CondTerm LOGICAL_AND CondFact
    | (SingleCondTerm) CondFact;

/*---------------IMPORTANT---------------*/
CondFact ::= (FullCondFact) TermExpr Relop TermExpr
    | (SingleCondFact) TermExpr;

TermExpr ::= (NextTermExpr) TermExpr Addop Term
    | (SingleTermExpr) OptionalMinus Term;

Term ::= (NextTerm) Term Mulop Factor
    | (SingleTerm) Factor;

Factor ::= (DesignatorFactor) Designator OptionalActParsWithBrackets
    | (ConstFactor) ConstValue
    | (NewOperatorFactor) NEW Type OptionalExprInBrackets
    | (ExprFactor) LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
    ;

OptionalExprInBrackets ::= (FullExprInBrackets) LEFT_SQUARE_BRACKET Expr RIGHT_SQUARE_BRACKET
    | (NoExprInBrackets);

OptionalActParsWithBrackets ::= (FullActParsWihBrackets) LEFT_PARENTHESIS OptionalActPars RIGHT_PARENTHESIS
    | (NoActParsWithBrackets);

OptionalActPars ::= (FullActPars) ActPars
    | (NoActPars);

ActPars ::= (NextActPar) ActPars COMMA Expr
    | (SingleActPar) Expr;

Designator ::= (InnerDotIdentDesignator) Designator DOT IDENT
    | (InnerExprInBracketsDesignator) Designator LEFT_SQUARE_BRACKET Expr RIGHT_SQUARE_BRACKET
    | (SingleDesignator) IDENT;

OptionalMinus ::= (Minus) SUB | (NoMinus);

OptionalVarDeclList ::= (FullVarDecl) OptionalVarDeclList VarDecls
    | (NoVarDecls);

VarDecls ::= (VarDecls) VarDecl SEMICOLON;

VarDecl ::= (NextVarDecl) VarDecl COMMA IDENT OptionalArrayBrackets
    | (SingleDecl) Type IDENT OptionalArrayBrackets;

ConstValue ::= (NumberConst) NUMCONST | (CharConst) CHARCONST | (BooleanConst) BOOLCONST;

OptionalExtendedClassLBrace ::= (ExtendedClass) EXTENDS Type LEFT_CURLY_BRACE
    | (ErrorExtendedClass) error LEFT_CURLY_BRACE:l
    {: parser.report_error("Izvrsen oporavak nekorektnog prosirenja klase, liniji " + lleft, null); :}
    | (NoExtendedClass) LEFT_CURLY_BRACE;

OptionalArrayBrackets ::= (ArrayBrackets) LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET
    | (NoArrayBrackets);

Type ::= (Type) IDENT;

Assignop ::= (Assignop) ASSIGN;

Relop ::= (EqualsRelop) EQUALS
    | (NotEqualsRelop) NOT_EQUALS
    | (GreaterEqualsRelop) GREATER_THAN_OR_EQUAL_TO
    | (GreaterRelop) GREATER_THAN
    | (LesserEqualsRelop) LESSER_THAN_OR_EQUAL_TO
    | (LesserRelop) LESSER_THAN;

Addop ::= (AddAddop) ADD
    | (SubAddop) SUB;

Mulop ::= (MulMulop) MUL
    | (DivMulop) DIV
    | (ModMulop) MOD;
